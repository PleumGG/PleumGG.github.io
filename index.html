<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Surgical Hand Demo (Mobile Fix)</title>
    <style>
        body { margin:0; overflow:hidden; background:#050505; font-family: sans-serif; }
        #ui {
            position: fixed; top: 10px; left: 10px; color: #00ffcc; z-index: 10;
            background: rgba(0,0,0,0.6); padding: 10px; border-radius: 5px; font-size: 14px;
        }
        #gesture-display { font-size: 20px; font-weight: bold; color: #fff; display: block; }
        video {
            position: fixed; left: 10px; bottom: 10px; width: 120px; height: 90px;
            transform: scaleX(-1); border: 1px solid #00ffcc; border-radius: 5px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

    <div id="ui">
        MODE: <span style="color:#00ffcc">MEDICAL DEMO</span>
        <span id="gesture-display">INITIALIZING...</span>
    </div>

    <video id="video" autoplay muted playsinline></video>

    <script>
        // 1. Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 5, 5);
        scene.add(light, new THREE.AmbientLight(0x404040));

        const cube = new THREE.Mesh(
            new THREE.BoxGeometry(2, 2, 2),
            [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff].map(c => new THREE.MeshStandardMaterial({color: c}))
        );
        scene.add(cube);
        camera.position.z = 6;

        let tRotX = 0, tRotY = 0, tZoom = 6;
        function animate() {
            requestAnimationFrame(animate);
            cube.rotation.x += (tRotX - cube.rotation.x) * 0.1;
            cube.rotation.y += (tRotY - cube.rotation.y) * 0.1;
            camera.position.z += (tZoom - camera.position.z) * 0.1;
            renderer.render(scene, camera);
        }
        animate();

        // 2. Gesture Logic (Fixed for Mobile)
        const display = document.getElementById("gesture-display");
        let lastAction = 0;

        function getGesture(lm) {
            // เช็คว่านิ้ว "ยืด" หรือ "พับ" โดยเทียบระยะจากข้อมือ (0)
            const dist = (pt) => Math.sqrt(Math.pow(lm[pt].x - lm[0].x, 2) + Math.pow(lm[pt].y - lm[0].y, 2));
            
            const fingerUp = [
                dist(8) > dist(6),  // ชี้
                dist(12) > dist(10), // กลาง
                dist(16) > dist(14), // นาง
                dist(20) > dist(18)  // ก้อย
            ];

            const upCount = fingerUp.filter(Boolean).length;

            // ท่าทางแบบชัดเจน
            if (upCount === 0) return "ZOOM_OUT"; // กำหมัด
            if (upCount === 4) return "ZOOM_IN";  // แบมือ (ชี้ กลาง นาง ก้อย)
            
            if (fingerUp[0] && upCount === 1) return "LEFT"; // ชี้หนึ่งนิ้ว
            if (fingerUp[0] && fingerUp[1] && upCount === 2) return "RIGHT"; // สองนิ้ว
            if (fingerUp[0] && fingerUp[1] && fingerUp[2] && upCount === 3) return "UP"; // สามนิ้ว
            
            // ท่าหมุนลง (ใช้ท่าเกี่ยวนิ้วชี้ลง หรือท่าเฉพาะ) 
            // ในที่นี้ถ้าไม่เข้าเงื่อนไขบนแต่มีการขยับ ให้เป็น DOWN
            if (upCount === 4 && lm[8].y > lm[5].y) return "DOWN"; 

            return "READY";
        }

        // 3. MediaPipe Setup
        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.75, minTrackingConfidence: 0.75 });

        hands.onResults(res => {
            if (!res.multiHandLandmarks?.length) {
                display.innerText = "NO HAND";
                return;
            }

            const lm = res.multiHandLandmarks[0];
            const gesture = getGesture(lm);
            display.innerText = "GESTURE: " + gesture;

            // หน่วงเวลา 800ms เพื่อไม่ให้มันทำงานเร็วไปจนคุมไม่ได้
            if (Date.now() - lastAction > 800) {
                if (gesture === "LEFT") tRotY -= Math.PI/2;
                if (gesture === "RIGHT") tRotY += Math.PI/2;
                if (gesture === "UP") tRotX -= Math.PI/2;
                if (gesture === "DOWN") tRotX += Math.PI/2;
                if (gesture === "ZOOM_IN") tZoom = Math.max(3, tZoom - 1.5);
                if (gesture === "ZOOM_OUT") tZoom = Math.min(10, tZoom + 1.5);
                
                if (gesture !== "READY") lastAction = Date.now();
            }
        });

        const cam = new Camera(document.getElementById("video"), {
            onFrame: async () => { await hands.send({image: document.getElementById("video")}); },
            width: 480, height: 360
        });
        cam.start();
    </script>
</body>
</html>
