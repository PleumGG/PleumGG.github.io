<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hand Control 3D (Optimized)</title>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
    }

    video {
      position: fixed;
      right: 10px;
      bottom: 10px;
      width: 140px;
      border: 2px solid white;
      z-index: 999;
    }

    canvas {
      z-index: 1;
    }
  </style>
</head>

<body>

<video id="video" autoplay playsinline muted></video>

<!-- LIBRARIES -->
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
  /* ================= THREE.JS ================= */
  const scene = new THREE.Scene();

  const camera3D = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );

  const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const geometry = new THREE.BoxGeometry();
  const material = new THREE.MeshNormalMaterial();
  const cube = new THREE.Mesh(geometry, material);
  scene.add(cube);

  camera3D.position.z = 3;

  let needRender = true;

  function animate() {
    requestAnimationFrame(animate);
    if (needRender) {
      renderer.render(scene, camera3D);
      needRender = false;
    }
  }
  animate();

  window.addEventListener("resize", () => {
    camera3D.aspect = window.innerWidth / window.innerHeight;
    camera3D.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    needRender = true;
  });

  /* ================= MEDIAPIPE ================= */
  const video = document.getElementById("video");

  const hands = new Hands({
    locateFile: (file) =>
      `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
  });

  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 0,          // ðŸ‘ˆ à¹€à¸šà¸²à¸ªà¸¸à¸”
    minDetectionConfidence: 0.6,
    minTrackingConfidence: 0.6,
  });

  let lastX = null;

  hands.onResults((results) => {
    if (results.multiHandLandmarks.length > 0) {
      const hand = results.multiHandLandmarks[0];
      const x = hand[9].x; // à¸ˆà¸¸à¸”à¸à¸¥à¸²à¸‡à¸à¹ˆà¸²à¸¡à¸·à¸­

      if (lastX !== null) {
        const dx = x - lastX;

        // dead zone à¸à¸±à¸™à¸¡à¸·à¸­à¸ªà¸±à¹ˆà¸™
        if (Math.abs(dx) > 0.03) {
          cube.rotation.y += dx * 4;
          needRender = true;
        }
      }

      lastX = x;
    }
  });

  const cameraFeed = new Camera(video, {
    onFrame: async () => {
      await hands.send({ image: video });
    },
    width: 320,        // ðŸ‘ˆ à¸¥à¸”à¸„à¸§à¸²à¸¡à¸¥à¸°à¹€à¸­à¸µà¸¢à¸”
    height: 240,
    facingMode: "user"
  });

  cameraFeed.start();
</script>

</body>
</html>
