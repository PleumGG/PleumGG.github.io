<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Hand Control Cube</title>

<style>
  body { margin:0; overflow:hidden; background:#000; }
  video {
    position:fixed;
    bottom:10px;
    right:10px;
    width:140px;
    border:2px solid white;
    border-radius:12px;
    z-index:10;
  }
</style>
</head>
<body>

<video id="webcam" autoplay playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ================= THREE SETUP ================= */
const scene = new THREE.Scene()

const camera = new THREE.PerspectiveCamera(
  70,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
)
camera.position.set(0,0,6)

const renderer = new THREE.WebGLRenderer({ antialias:true })
renderer.setSize(window.innerWidth, window.innerHeight)
document.body.appendChild(renderer.domElement)

window.addEventListener("resize",()=>{
  camera.aspect = window.innerWidth / window.innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(window.innerWidth, window.innerHeight)
})

const geometry = new THREE.BoxGeometry(2,2,2)
const material = new THREE.MeshNormalMaterial()
const cube = new THREE.Mesh(geometry, material)
scene.add(cube)

/* ================= CAMERA SPACE ROTATION ================= */
function rotateLeft(){
  const right = new THREE.Vector3()
  const forward = new THREE.Vector3()
  camera.getWorldDirection(forward)
  right.crossVectors(forward, camera.up).normalize()
  cube.rotateOnWorldAxis(right, Math.PI/2)
}

function rotateRight(){
  const right = new THREE.Vector3()
  const forward = new THREE.Vector3()
  camera.getWorldDirection(forward)
  right.crossVectors(forward, camera.up).normalize()
  cube.rotateOnWorldAxis(right, -Math.PI/2)
}

function rotateUp(){
  const up = new THREE.Vector3()
  up.copy(camera.up).normalize()
  cube.rotateOnWorldAxis(up, Math.PI/2)
}

function rotateDown(){
  const up = new THREE.Vector3()
  up.copy(camera.up).normalize()
  cube.rotateOnWorldAxis(up, -Math.PI/2)
}

/* ================= HAND TRACKING ================= */
const videoElement = document.getElementById("webcam")

const hands = new Hands({
  locateFile: (file)=>{
    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
  }
})

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
})

let cooldown = false

hands.onResults(results=>{
  if(!results.multiHandLandmarks || cooldown) return

  const landmarks = results.multiHandLandmarks[0]

  const fingersUp = countFingers(landmarks)

  if(fingersUp === 1) { rotateLeft(); cooldown=true }
  if(fingersUp === 2) { rotateRight(); cooldown=true }
  if(fingersUp === 3) { rotateUp(); cooldown=true }
  if(fingersUp === 4) { rotateDown(); cooldown=true }

  if(cooldown){
    setTimeout(()=> cooldown=false , 700)
  }
})

function countFingers(landmarks){
  let count = 0

  // index
  if(landmarks[8].y < landmarks[6].y) count++
  // middle
  if(landmarks[12].y < landmarks[10].y) count++
  // ring
  if(landmarks[16].y < landmarks[14].y) count++
  // pinky
  if(landmarks[20].y < landmarks[18].y) count++

  return count
}

const cam = new Camera(videoElement,{
  onFrame: async()=>{
    await hands.send({image: videoElement})
  },
  width: 640,
  height: 480
})
cam.start()

/* ================= RENDER LOOP ================= */
function animate(){
  requestAnimationFrame(animate)
  renderer.render(scene, camera)
}
animate()
</script>

</body>
</html>
