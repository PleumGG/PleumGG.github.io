<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hand Gesture Control - REAL 3D FIXED</title>

<style>
body { margin:0; overflow:hidden; background:black; }
video{
  position:fixed;
  right:10px;
  bottom:10px;
  width:200px;
  transform:scaleX(-1);
  opacity:0.4;
}
</style>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>

<body>
<video id="video" autoplay muted playsinline></video>

<script>

/* ========= THREE ========= */

const scene = new THREE.Scene()
scene.background = new THREE.Color(0x111111)
scene.fog = new THREE.Fog(0x111111, 5, 20) // เพิ่ม depth

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000)
camera.position.set(4,3,6)

const renderer = new THREE.WebGLRenderer({ antialias:true })
renderer.setSize(innerWidth, innerHeight)
renderer.shadowMap.enabled = true
document.body.appendChild(renderer.domElement)

/* ===== OrbitControls ===== */
const controls = new THREE.OrbitControls(camera, renderer.domElement)
controls.enableDamping = true

/* ===== Lights ===== */

scene.add(new THREE.AmbientLight(0xffffff, 0.4))

const dirLight = new THREE.DirectionalLight(0xffffff, 1.2)
dirLight.position.set(5,10,5)
dirLight.castShadow = true
scene.add(dirLight)

/* ===== Grid ===== */
const grid = new THREE.GridHelper(20,20)
scene.add(grid)

/* ===== Floor ===== */
const plane = new THREE.Mesh(
  new THREE.PlaneGeometry(30,30),
  new THREE.MeshStandardMaterial({ color:0x222222 })
)
plane.rotation.x = -Math.PI/2
plane.receiveShadow = true
scene.add(plane)

/* ===== Cube ===== */

const materials = [
  new THREE.MeshStandardMaterial({ color: 0xff0000 }),
  new THREE.MeshStandardMaterial({ color: 0x00ff00 }),
  new THREE.MeshStandardMaterial({ color: 0x0000ff }),
  new THREE.MeshStandardMaterial({ color: 0xffff00 }),
  new THREE.MeshStandardMaterial({ color: 0xff00ff }),
  new THREE.MeshStandardMaterial({ color: 0x00ffff })
]

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(1,1,1),
  materials
)

cube.castShadow = true
cube.position.y = 0.5
scene.add(cube)

let targetRotationY = cube.rotation.y
let targetRotationX = cube.rotation.x

function animate(){
  requestAnimationFrame(animate)

  cube.rotation.y += (targetRotationY - cube.rotation.y) * 0.1
  cube.rotation.x += (targetRotationX - cube.rotation.x) * 0.1

  controls.update()
  renderer.render(scene, camera)
}
animate()

/* ========= MEDIAPIPE ========= */

const video = document.getElementById("video")

const hands = new Hands({
  locateFile: f =>
    `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
})

hands.setOptions({
  maxNumHands:1,
  modelComplexity:1,
  minDetectionConfidence:0.7,
  minTrackingConfidence:0.7
})

let gestureStartTime = null
let currentGesture = null
let gestureLocked = false

function isPalmFacingCamera(lm){
  return lm[9].z < lm[0].z
}

function countRaisedFingers(lm){
  let count = 0
  if(lm[8].y < lm[6].y) count++
  if(lm[12].y < lm[10].y) count++
  if(lm[16].y < lm[14].y) count++
  if(lm[20].y < lm[18].y) count++
  return count
}

hands.onResults(res=>{
  if(!res.multiHandLandmarks?.length){
    gestureStartTime = null
    currentGesture = null
    gestureLocked = false
    return
  }

  const lm = res.multiHandLandmarks[0]

  if(!isPalmFacingCamera(lm)){
    gestureStartTime = null
    currentGesture = null
    gestureLocked = false
    return
  }

  const fingerCount = countRaisedFingers(lm)

  let detectedGesture = null
  if(fingerCount === 1) detectedGesture = "LEFT"
  if(fingerCount === 2) detectedGesture = "RIGHT"
  if(fingerCount === 3) detectedGesture = "UP"
  if(fingerCount === 4) detectedGesture = "DOWN"

  if(detectedGesture !== currentGesture){
    gestureStartTime = Date.now()
    currentGesture = detectedGesture
    gestureLocked = false
  }

  if(detectedGesture && !gestureLocked){
    const heldTime = Date.now() - gestureStartTime

    if(heldTime > 800){

      if(detectedGesture === "LEFT")  targetRotationY -= Math.PI/2
      if(detectedGesture === "RIGHT") targetRotationY += Math.PI/2
      if(detectedGesture === "UP")    targetRotationX -= Math.PI/4
      if(detectedGesture === "DOWN")  targetRotationX += Math.PI/4

      gestureLocked = true
    }
  }
})

const cam = new Camera(video,{
  onFrame: async ()=>{
    await hands.send({ image: video })
  },
  width:640,
  height:480
})
cam.start()

addEventListener("resize",()=>{
  camera.aspect = innerWidth/innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(innerWidth, innerHeight)
})

</script>
</body>
</html>
