<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Surgical Control v4.1 - Fix Aspect Ratio</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; font-family: 'Courier New', monospace; touch-action: none; }
        
        #ui {
            position: fixed; top: 15px; left: 15px; color: #00ffcc; z-index: 1000;
            background: rgba(0,25,25,0.85); padding: 15px; border-left: 5px solid #00ffcc;
            min-width: 220px; pointer-events: none; border-radius: 0 8px 8px 0;
        }
        .command-text { font-size: 22px; font-weight: bold; color: white; margin-bottom: 5px; }
        #progress-container { width: 100%; height: 10px; background: #111; border: 1px solid #333; margin: 8px 0; }
        #progress-bar { width: 0%; height: 100%; background: #00ffcc; box-shadow: 0 0 10px #00ffcc; transition: width 0.05s linear; }

        /* กรอบกล้อง - ปรับขนาดให้เป็นสัดส่วนมาตรฐานมือถือ */
        #camera-monitor {
            position: fixed; 
            right: 15px; 
            bottom: 15px; 
            width: 150px; 
            height: 150px; /* ทำเป็นสี่เหลี่ยมจัตุรัสให้ดูเท่แบบสโคปหมอ */
            z-index: 9999; 
            border: 2px solid #00ffcc;
            border-radius: 50%; /* เปลี่ยนเป็นวงกลมดูเป็น Surgical Monitor มากขึ้น */
            background: #000;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.4);
        }

        #camera-canvas {
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Mirror ภาพ */
        }

        #video { position: fixed; width: 1px; height: 1px; opacity: 0; pointer-events: none; }
    </style>
</head>
<body>

    <div id="ui">
        <div style="font-size:10px; color:#00ccaa;">MONITORING v4.1</div>
        <div id="gesture-display" class="command-text">READY</div>
        <div id="progress-container"><div id="progress-bar"></div></div>
    </div>

    <div id="camera-monitor">
        <canvas id="camera-canvas" width="300" height="300"></canvas>
    </div>

    <video id="video" autoplay muted playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const videoElement = document.getElementById('video');
        const canvasElement = document.getElementById('camera-canvas');
        const canvasCtx = canvasElement.getContext('2d');

        /* --- 1. THREE.JS --- */
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const cube = new THREE.Mesh(
            new THREE.BoxGeometry(2.5, 2.5, 2.5),
            [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff, 0x44ffff].map(c => new THREE.MeshStandardMaterial({color: c, roughness: 0.2}))
        );
        scene.add(cube);
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        camera.position.z = 8;

        let targetZoom = 8;
        let targetQuaternion = new THREE.Quaternion();

        function animate() {
            requestAnimationFrame(animate);
            cube.quaternion.slerp(targetQuaternion, 0.15);
            camera.position.z += (targetZoom - camera.position.z) * 0.1;
            renderer.render(scene, camera);

            // วาดภาพแบบ "Aspect Ratio Fix" (Center Crop)
            if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
                const vW = videoElement.videoWidth;
                const vH = videoElement.videoHeight;
                const cW = canvasElement.width;
                const cH = canvasElement.height;
                
                // คำนวณสัดส่วนเพื่อให้ภาพไม่แบน
                const aspect = vW / vH;
                let drawW, drawH, offsetX, offsetY;
                
                if (aspect > 1) { // แนวนอน
                    drawH = vH;
                    drawW = vH; // ตัดให้เป็นจัตุรัส
                    offsetX = (vW - vH) / 2;
                    offsetY = 0;
                } else { // แนวตั้ง
                    drawW = vW;
                    drawH = vW;
                    offsetX = 0;
                    offsetY = (vH - vW) / 2;
                }

                canvasCtx.drawImage(videoElement, offsetX, offsetY, drawW, drawH, 0, 0, cW, cH);
            }
            if (videoElement.paused) videoElement.play();
        }
        animate();

        /* --- 2. GESTURE & CAMERA --- */
        function checkFingers(lm) {
            const d = (pt) => Math.sqrt(Math.pow(lm[pt].x - lm[0].x, 2) + Math.pow(lm[pt].y - lm[0].y, 2));
            return {
                index: d(8) > d(6) * 1.15,
                middle: d(12) > d(10) * 1.15,
                ring: d(16) > d(14) * 1.15,
                pinky: d(20) > d(18) * 1.15
            };
        }

        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });

        let activeGesture = "READY";
        let startTime = null;
        let isLocked = false;

        hands.onResults(res => {
            let detected = "READY";
            if (res.multiHandLandmarks?.length > 0) {
                const lm = res.multiHandLandmarks[0];
                const label = res.multiHandedness[0].label;
                const f = checkFingers(lm);
                const isFisted = !f.middle && !f.ring;

                if (label === "Left") {
                    if (f.pinky && isFisted && !f.index) detected = "ROTATE LEFT";
                    else if (f.index && isFisted && !f.pinky) detected = "ROTATE RIGHT";
                    else if (f.index && f.middle && !f.ring && !f.pinky) detected = "ROTATE UP";
                    else if (f.index && f.middle && f.ring && !f.pinky) detected = "ROTATE DOWN";
                } else {
                    if (f.pinky && isFisted && !f.index) detected = "ZOOM IN";
                    else if (f.index && isFisted && !f.pinky) detected = "ZOOM OUT";
                }
            }

            if (detected !== "READY") {
                if (detected === activeGesture) {
                    if (!isLocked) {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min((elapsed / 1000) * 100, 100);
                        document.getElementById("progress-bar").style.width = progress + "%";
                        document.getElementById("gesture-display").innerText = detected;
                        if (elapsed >= 1000) { runCommand(detected); isLocked = true; }
                    }
                } else {
                    activeGesture = detected; startTime = Date.now(); isLocked = false;
                    document.getElementById("progress-bar").style.width = "0%";
                }
            } else {
                activeGesture = "READY"; startTime = null; isLocked = false;
                document.getElementById("progress-bar").style.width = "0%";
                document.getElementById("gesture-display").innerText = "READY";
            }
        });

        function runCommand(cmd) {
            const angle = Math.PI / 2;
            const q = new THREE.Quaternion();
            if (cmd === "ROTATE LEFT") q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), -angle);
            if (cmd === "ROTATE RIGHT") q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
            if (cmd === "ROTATE UP") q.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -angle);
            if (cmd === "ROTATE DOWN") q.setFromAxisAngle(new THREE.Vector3(1, 0, 0), angle);
            targetQuaternion.multiplyQuaternions(q, targetQuaternion);
            if (cmd === "ZOOM IN") targetZoom = Math.max(2, targetZoom - 2);
            if (cmd === "ZOOM OUT") targetZoom = Math.min(12, targetZoom + 2);
            renderer.domElement.style.filter = "brightness(2)";
            setTimeout(() => renderer.domElement.style.filter = "brightness(1)", 150);
        }

        const cam = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 480, height: 360
        });
        cam.start();
    </script>
</body>
</html>
