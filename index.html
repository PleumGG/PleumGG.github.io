<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Medical Hand Gesture Demo</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <style>
    body { margin:0; overflow:hidden; background:#111; }
    canvas { position:absolute; left:0; top:0; }
    #cube {
      width:150px;
      height:150px;
      background:#00bcd4;
      position:absolute;
      top:50%;
      left:50%;
      transform-style:preserve-3d;
      transform:translate(-50%,-50%) rotateX(0deg) scale(1);
      transition: transform 0.2s ease-out;
    }
  </style>
</head>
<body>

<video class="input_video" style="display:none"></video>
<canvas class="output_canvas"></canvas>
<div id="cube"></div>

<script>
const videoElement = document.querySelector('.input_video');
const canvasElement = document.querySelector('.output_canvas');
const canvasCtx = canvasElement.getContext('2d');
const cube = document.getElementById("cube");

canvasElement.width = window.innerWidth;
canvasElement.height = window.innerHeight;

let rotationX = 0;
let scale = 1;

let lastGesture = null;
let stableFrames = 0;
let lastExecuted = 0;

const STABLE_THRESHOLD = 12;
const COOLDOWN = 1000;

// ===== Robust Finger Detection =====
function distance(a,b){
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return Math.sqrt(dx*dx + dy*dy);
}

function isFingerExtended(tip, mcp){
  return distance(tip, mcp) > 0.09;
}

function getGesture(lm){

  const thumb = isFingerExtended(lm[4], lm[2]);
  const index = isFingerExtended(lm[8], lm[5]);
  const middle = isFingerExtended(lm[12], lm[9]);
  const ring = isFingerExtended(lm[16], lm[13]);
  const pinky = isFingerExtended(lm[20], lm[17]);

  // ---- Priority Order (no overlap) ----

  // âœ‹ 5 fingers â†’ Zoom In
  if(thumb && index && middle && ring && pinky)
    return "ZOOM_IN";

  // ðŸ‘† index only â†’ Rotate Down
  if(!thumb && index && !middle && !ring && !pinky)
    return "ROTATE_DOWN";

  // âœŒ index + middle â†’ Rotate Up
  if(!thumb && index && middle && !ring && !pinky)
    return "ROTATE_UP";

  // âœŠ fist â†’ Zoom Out
  if(!thumb && !index && !middle && !ring && !pinky)
    return "ZOOM_OUT";

  return null;
}

// ===== Execute Gesture =====
function executeGesture(gesture){

  if(Date.now() - lastExecuted < COOLDOWN) return;

  switch(gesture){
    case "ZOOM_IN":
      scale += 0.2;
      break;

    case "ZOOM_OUT":
      scale = Math.max(0.5, scale - 0.2);
      break;

    case "ROTATE_UP":
      rotationX -= 20;
      break;

    case "ROTATE_DOWN":
      rotationX += 20;
      break;
  }

  cube.style.transform =
    `translate(-50%,-50%) rotateX(${rotationX}deg) scale(${scale})`;

  lastExecuted = Date.now();
}

// ===== MediaPipe Setup =====
const hands = new Hands({
  locateFile: file =>
    `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.8,
  minTrackingConfidence: 0.8
});

hands.onResults(results => {

  canvasCtx.save();
  canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

  if(results.multiHandLandmarks.length > 0){

    const lm = results.multiHandLandmarks[0];
    const gesture = getGesture(lm);

    if(gesture === lastGesture){
      stableFrames++;
    }else{
      stableFrames = 0;
    }

    lastGesture = gesture;

    if(stableFrames > STABLE_THRESHOLD && gesture){
      executeGesture(gesture);
      stableFrames = 0;
    }

    drawConnectors(canvasCtx, lm, HAND_CONNECTIONS);
    drawLandmarks(canvasCtx, lm);

  }else{
    stableFrames = 0;
    lastGesture = null;
  }

  canvasCtx.restore();
});

// ===== Camera =====
const camera = new Camera(videoElement, {
  onFrame: async () => {
    await hands.send({image: videoElement});
  },
  width: 640,
  height: 480
});
camera.start();
</script>

</body>
</html>
