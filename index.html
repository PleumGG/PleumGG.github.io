<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ========= THREE ========= */
const scene = new THREE.Scene()
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000)
camera.position.z = 4

const renderer = new THREE.WebGLRenderer({ antialias:true })
renderer.setSize(innerWidth, innerHeight)
document.body.appendChild(renderer.domElement)

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(1,1,1),
  new THREE.MeshNormalMaterial()
)
scene.add(cube)

function animate(){
  requestAnimationFrame(animate)
  renderer.render(scene, camera)
}
animate()

/* ========= VIDEO ========= */
const video = document.getElementById("video")
video.muted = true
video.playsInline = true

/* ========= HAND ========= */
const hands = new Hands({
  locateFile: f =>
    `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
})

hands.setOptions({
  maxNumHands:1,
  modelComplexity:0,
  minDetectionConfidence:0.6,
  minTrackingConfidence:0.6
})

let lastX=null, lastY=null

hands.onResults(res=>{
  if(!res.multiHandLandmarks?.length){
    lastX = lastY = null
    return
  }

  const p = res.multiHandLandmarks[0][9]

  if(lastX!==null){
    cube.rotation.y += (p.x-lastX)*6
    cube.rotation.x += (p.y-lastY)*6
  }

  lastX = p.x
  lastY = p.y
})

/* ========= CAMERA (ตัวแก้ปัญหาดำ) ========= */
const cam = new Camera(video, {
  onFrame: async () => {
    await hands.send({ image: video })
  },
  width: 640,
  height: 480
})

cam.start()

/* ========= RESIZE ========= */
addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(innerWidth, innerHeight)
})
</script>
