<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Gesture Controlled OR Prototype</title>

<style>
body { margin:0; overflow:hidden; background:black; }

video{
  position:fixed;
  right:10px;
  bottom:10px;
  width:200px;
  transform:scaleX(-1);
  opacity:1;
}
</style>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>

<body>
<video id="video" autoplay muted playsinline></video>

<script>

/* ================= THREE ================= */

const scene = new THREE.Scene()
scene.background = new THREE.Color(0x111111)

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000)
camera.position.set(2,2,6)
camera.lookAt(0,0,0)

const renderer = new THREE.WebGLRenderer({ antialias:true })
renderer.setSize(innerWidth, innerHeight)
document.body.appendChild(renderer.domElement)

scene.add(new THREE.AmbientLight(0xffffff, 0.6))

const light = new THREE.DirectionalLight(0xffffff, 1)
light.position.set(5,5,5)
scene.add(light)

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(1,1,1),
  [
    new THREE.MeshStandardMaterial({ color:0xff0000 }),
    new THREE.MeshStandardMaterial({ color:0x00ff00 }),
    new THREE.MeshStandardMaterial({ color:0x0000ff }),
    new THREE.MeshStandardMaterial({ color:0xffff00 }),
    new THREE.MeshStandardMaterial({ color:0xff00ff }),
    new THREE.MeshStandardMaterial({ color:0x00ffff })
  ]
)

cube.rotation.set(0.5,0.5,0)
scene.add(cube)

/* ============== SMOOTH TARGET VALUES ============== */

let targetRotX = cube.rotation.x
let targetRotY = cube.rotation.y
let targetZoom = camera.position.z

function animate(){
  requestAnimationFrame(animate)

  cube.rotation.x += (targetRotX - cube.rotation.x) * 0.15
  cube.rotation.y += (targetRotY - cube.rotation.y) * 0.15
  camera.position.z += (targetZoom - camera.position.z) * 0.15

  renderer.render(scene, camera)
}
animate()

/* ================= MEDIAPIPE ================= */

const video = document.getElementById("video")

const hands = new Hands({
  locateFile: f =>
  `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
})

hands.setOptions({
  maxNumHands:1,
  modelComplexity:1,
  minDetectionConfidence:0.75,
  minTrackingConfidence:0.75
})

/* ================= STATE CONTROL ================= */

let gestureStartTime = 0
let lastExecutedTime = 0
let currentGesture = null

const HOLD_TIME = 500       // ต้องค้าง 0.5 วิ
const COOLDOWN_TIME = 700   // กัน spam

/* ================= HELPER FUNCTIONS ================= */

function isRightHand(res){
  return res.multiHandedness?.[0]?.label === "Right"
}

function mirrorLandmarks(lm){
  return lm.map(p => ({ ...p, x: 1 - p.x }))
}

function distance(a,b){
  return Math.hypot(a.x-b.x, a.y-b.y)
}

function isPalmFacingCamera(lm){
  return lm[9].z < lm[0].z
}

function getGesture(lm){

  const thumb  = distance(lm[4], lm[2]) > 0.07
  const index  = lm[8].y < lm[6].y
  const middle = lm[12].y < lm[10].y
  const ring   = lm[16].y < lm[14].y
  const pinky  = lm[20].y < lm[18].y

  if(!thumb && !index && !middle && !ring && !pinky)
    return "ZOOM_OUT"

  if(!thumb && index && !middle && !ring && !pinky)
    return "LEFT"

  if(!thumb && index && middle && !ring && !pinky)
    return "RIGHT"

  if(!thumb && index && middle && ring && !pinky)
    return "UP"

  if(!thumb && index && middle && ring && pinky)
    return "DOWN"

  if(thumb && index && middle && ring && pinky)
    return "ZOOM_IN"

  return null
}

/* ================= MAIN DETECTION ================= */

hands.onResults(res=>{

  if(!res.multiHandLandmarks?.length) return
  if(!isRightHand(res)) return

  const lm = mirrorLandmarks(res.multiHandLandmarks[0])
  if(!isPalmFacingCamera(lm)) return

  const detected = getGesture(lm)
  const now = Date.now()

  if(detected !== currentGesture){
    currentGesture = detected
    gestureStartTime = now
  }

  if(!detected) return

  if(now - gestureStartTime > HOLD_TIME &&
     now - lastExecutedTime > COOLDOWN_TIME){

    executeGesture(detected)
    lastExecutedTime = now
  }

})

/* ================= ACTION EXECUTION ================= */

function executeGesture(g){

  if(g === "LEFT")  targetRotY -= Math.PI/2
  if(g === "RIGHT") targetRotY += Math.PI/2
  if(g === "UP")    targetRotX -= Math.PI/2
  if(g === "DOWN")  targetRotX += Math.PI/2

  if(g === "ZOOM_IN"){
    targetZoom = Math.max(2, targetZoom - 1)
  }

  if(g === "ZOOM_OUT"){
    targetZoom = Math.min(12, targetZoom + 1)
  }

}

/* ================= CAMERA STREAM ================= */

const cam = new Camera(video,{
  onFrame: async ()=>{
    await hands.send({ image: video })
  },
  width:640,
  height:480
})
cam.start()

/* ================= RESPONSIVE ================= */

addEventListener("resize",()=>{
  camera.aspect = innerWidth/innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(innerWidth, innerHeight)
})

</script>
</body>
</html>
