<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Surgical Precision Interface</title>
    <style>
        body { margin:0; overflow:hidden; background:#020202; font-family: 'Segoe UI', sans-serif; }
        #ui {
            position: fixed; top: 20px; left: 20px; color: #00ffcc; z-index: 10;
            background: rgba(0,25,25,0.85); padding: 20px; border-radius: 8px;
            border: 1px solid #00ffcc; min-width: 220px;
        }
        .cmd-label { font-size: 14px; color: #00ccaa; text-transform: uppercase; }
        #gesture-display { font-size: 28px; font-weight: bold; color: white; margin: 5px 0; }
        
        /* แถบ Progress การยืนยันคำสั่ง */
        #progress-container { width: 100%; height: 8px; background: #111; border-radius: 4px; overflow: hidden; margin-top: 10px; }
        #progress-bar { width: 0%; height: 100%; background: #00ffcc; transition: width 0.1s linear; }
        
        video {
            position: fixed; right: 20px; bottom: 20px; width: 180px; 
            transform: scaleX(-1); border-radius: 12px; border: 2px solid #333;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

    <div id="ui">
        <div class="cmd-label">System Status: Active</div>
        <div id="gesture-display">READY</div>
        <div id="progress-container"><div id="progress-bar"></div></div>
        <div style="font-size: 11px; margin-top: 12px; color: #888; line-height: 1.4;">
            <b>HOLD GESTURE 0.7S TO EXECUTE</b><br>
            Left Hand: Rotate View | Right Hand: Zoom
        </div>
    </div>

    <video id="video" autoplay muted playsinline></video>

    <script>
        /* --- THREE.JS SCENE --- */
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1.2);
        light.position.set(5, 5, 5);
        scene.add(light, new THREE.AmbientLight(0xffffff, 0.4));

        const cube = new THREE.Mesh(
            new THREE.BoxGeometry(2.2, 2.2, 2.2),
            [0xff3e3e, 0x3eff3e, 0x3e3eff, 0xffff3e, 0xff3eff, 0x3effff].map(c => new THREE.MeshStandardMaterial({color: c, roughness: 0.3}))
        );
        scene.add(cube);
        camera.position.z = 6;

        let tRotX = 0, tRotY = 0, tZoom = 6;
        function animate() {
            requestAnimationFrame(animate);
            cube.rotation.x += (tRotX - cube.rotation.x) * 0.12;
            cube.rotation.y += (tRotY - cube.rotation.y) * 0.12;
            camera.position.z += (tZoom - camera.position.z) * 0.12;
            renderer.render(scene, camera);
        }
        animate();

        /* --- SURGICAL GESTURE LOGIC --- */
        const display = document.getElementById("gesture-display");
        const progressBar = document.getElementById("progress-bar");
        
        let currentGesture = "READY";
        let gestureStartTime = 0;
        let isExecuted = false; // ตัวแปรล็อค ไม่ให้ทำซ้ำในท่าเดิม
        const HOLD_TIME = 700; // 0.7 วินาที

        function checkFingers(lm) {
            const dist = (pt) => Math.sqrt(Math.pow(lm[pt].x - lm[0].x, 2) + Math.pow(lm[pt].y - lm[0].y, 2));
            return {
                thumb: dist(4) > dist(2) * 1.4,
                index: dist(8) > dist(6),
                middle: dist(12) > dist(10),
                ring: dist(16) > dist(14)
            };
        }

        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.75, minTrackingConfidence: 0.75 });

        hands.onResults(res => {
            let detected = "READY";

            if (res.multiHandLandmarks?.length > 0) {
                res.multiHandLandmarks.forEach((lm, index) => {
                    const label = res.multiHandedness[index].label; 
                    const f = checkFingers(lm);

                    if (label === "Left") {
                        if (f.thumb && !f.index && !f.middle) detected = "ROTATE LEFT";
                        else if (!f.thumb && f.index && !f.middle) detected = "ROTATE RIGHT";
                        else if (f.index && f.middle && !f.ring) detected = "ROTATE UP";
                        else if (f.index && f.middle && f.ring) detected = "ROTATE DOWN";
                    } 
                    else if (label === "Right") {
                        if (f.thumb && !f.index) detected = "ZOOM IN";
                        else if (!f.thumb && f.index) detected = "ZOOM OUT";
                    }
                });
            }

            // ถ้านิ้วเปลี่ยนท่า ให้ Reset การนับเวลาและตัวล็อค
            if (detected !== currentGesture) {
                currentGesture = detected;
                gestureStartTime = Date.now();
                isExecuted = false;
                progressBar.style.width = "0%";
            }

            if (currentGesture !== "READY" && !isExecuted) {
                const elapsed = Date.now() - gestureStartTime;
                const progress = Math.min((elapsed / HOLD_TIME) * 100, 100);
                progressBar.style.width = progress + "%";
                display.innerText = currentGesture;

                // เมื่อค้างครบ 0.7 วินาที และยังไม่ได้รันคำสั่ง
                if (elapsed >= HOLD_TIME) {
                    executeCommand(currentGesture);
                    isExecuted = true; // ล็อคไว้จนกว่าจะเปลี่ยนท่า
                    progressBar.style.backgroundColor = "#ffcc00"; // เปลี่ยนสีบอกว่ารันแล้ว
                    setTimeout(() => { progressBar.style.backgroundColor = "#00ffcc"; }, 300);
                }
            } else if (isExecuted) {
                display.innerText = "DONE: " + currentGesture;
                progressBar.style.width = "100%";
            } else {
                display.innerText = "READY";
                progressBar.style.width = "0%";
            }
        });

        function executeCommand(cmd) {
            if (cmd === "ROTATE LEFT") tRotY -= Math.PI/2;
            if (cmd === "ROTATE RIGHT") tRotY += Math.PI/2;
            if (cmd === "ROTATE UP") tRotX -= Math.PI/2;
            if (cmd === "ROTATE DOWN") tRotX += Math.PI/2;
            if (cmd === "ZOOM IN") tZoom = Math.max(2, tZoom - 1.5);
            if (cmd === "ZOOM OUT") tZoom = Math.min(12, tZoom + 1.5);
        }

        const cam = new Camera(document.getElementById("video"), {
            onFrame: async () => { await hands.send({image: document.getElementById("video")}); },
            width: 480, height: 360
        });
        cam.start();
    </script>
</body>
</html>
