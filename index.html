<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Surgical Precision - Fixed Step</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; font-family: 'Segoe UI', sans-serif; }
        #ui {
            position: fixed; top: 20px; left: 20px; color: #00ffcc; z-index: 10;
            background: rgba(0,20,20,0.9); padding: 15px; border: 1px solid #00ffcc;
            border-radius: 4px; min-width: 220px;
        }
        #gesture-name { font-size: 24px; font-weight: bold; color: white; }
        #progress-bar { width: 0%; height: 6px; background: #00ffcc; margin-top: 8px; transition: width 0.1s linear; }
        .instruction { font-size: 10px; color: #888; margin-top: 8px; }
        video {
            position: fixed; right: 10px; bottom: 10px; width: 140px; 
            transform: scaleX(-1); border-radius: 8px; border: 1px solid #333;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

    <div id="ui">
        <div style="font-size: 12px; color: #00ffcc;">SURGICAL SYSTEM v3</div>
        <div id="gesture-name">READY</div>
        <div id="progress-bar"></div>
        <div class="instruction">
            L-Hand: T=Left, I=Right, 2F=Up, 3F=Down<br>
            R-Hand: T=Zoom In, I=Zoom Out<br>
            <b style="color:#ffcc00">RELEASE HAND TO RESET AFTER ACTION</b>
        </div>
    </div>

    <video id="video" autoplay muted playsinline></video>

    <script>
        /* --- THREE.JS --- */
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(5, 5, 5);
        scene.add(light, new THREE.AmbientLight(0xffffff, 0.3));

        const cube = new THREE.Mesh(
            new THREE.BoxGeometry(2, 2, 2),
            [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff].map(c => new THREE.MeshStandardMaterial({color: c}))
        );
        scene.add(cube);
        camera.position.z = 6;

        let tRotX = 0, tRotY = 0, tZoom = 6;
        function animate() {
            requestAnimationFrame(animate);
            cube.rotation.x += (tRotX - cube.rotation.x) * 0.1;
            cube.rotation.y += (tRotY - cube.rotation.y) * 0.1;
            camera.position.z += (tZoom - camera.position.z) * 0.1;
            renderer.render(scene, camera);
        }
        animate();

        /* --- LOGIC --- */
        let currentGesture = "READY";
        let gestureStartTime = 0;
        let isLocked = false; // ตัวล็อค Action

        function getHandGesture(lm, label) {
            const dist = (p1, p2) => Math.sqrt(Math.pow(lm[p1].x - lm[p2].x, 2) + Math.pow(lm[p1].y - lm[p2].y, 2));
            const isUp = (tip, base) => lm[tip].y < lm[base].y;

            const thumb = dist(4, 17) > dist(2, 17) * 1.2;
            const index = isUp(8, 6);
            const middle = isUp(12, 10);
            const ring = isUp(16, 14);

            if (label === "Left") {
                if (thumb && !index && !middle) return "LEFT";
                if (!thumb && index && !middle) return "RIGHT";
                if (index && middle && !ring) return "UP";
                if (index && middle && ring) return "DOWN";
            } else {
                if (thumb && !index) return "ZOOM_IN";
                if (!thumb && index) return "ZOOM_OUT";
            }
            return "READY";
        }

        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ maxNumHands: 2, minDetectionConfidence: 0.8, minTrackingConfidence: 0.8 });

        hands.onResults(res => {
            let detected = "READY";
            if (res.multiHandLandmarks?.length) {
                res.multiHandLandmarks.forEach((lm, i) => {
                    const label = res.multiHandedness[i].label;
                    const g = getHandGesture(lm, label);
                    if (g !== "READY") detected = g;
                });
            }

            if (detected !== currentGesture) {
                currentGesture = detected;
                gestureStartTime = Date.now();
                isLocked = false; // ปลดล็อคเมื่อเปลี่ยนท่า
                document.getElementById("progress-bar").style.width = "0%";
            }

            if (currentGesture !== "READY" && !isLocked) {
                const elapsed = Date.now() - gestureStartTime;
                const progress = Math.min((elapsed / 700) * 100, 100);
                document.getElementById("progress-bar").style.width = progress + "%";
                document.getElementById("gesture-name").innerText = currentGesture;

                if (elapsed >= 700) {
                    // ทำงานแค่ครั้งเดียว
                    if (currentGesture === "LEFT") tRotY -= Math.PI/2;
                    if (currentGesture === "RIGHT") tRotY += Math.PI/2;
                    if (currentGesture === "UP") tRotX -= Math.PI/2;
                    if (currentGesture === "DOWN") tRotX += Math.PI/2;
                    if (currentGesture === "ZOOM_IN") tZoom = Math.max(2, tZoom - 1.5);
                    if (currentGesture === "ZOOM_OUT") tZoom = Math.min(12, tZoom + 1.5);
                    
                    isLocked = true; // ล็อคทันทีหลังจากสั่งงาน
                    document.getElementById("gesture-name").innerText = "EXECUTED";
                }
            } else if (isLocked) {
                document.getElementById("progress-bar").style.width = "100%";
                document.getElementById("gesture-name").innerText = "LOCKED (RELEASE)";
            } else {
                document.getElementById("gesture-name").innerText = "READY";
            }
        });

        const cam = new Camera(document.getElementById("video"), {
            onFrame: async () => { await hands.send({image: document.getElementById("video")}); },
            width: 480, height: 360
        });
        cam.start();
    </script>
</body>
</html>
