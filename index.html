<script>
/* ========= THREE ========= */
const scene = new THREE.Scene()
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000)
camera.position.z = 4

const renderer = new THREE.WebGLRenderer({ antialias:true })
renderer.setSize(innerWidth, innerHeight)
document.body.appendChild(renderer.domElement)

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(1,1,1),
  new THREE.MeshNormalMaterial()
)
scene.add(cube)

function animate(){
  requestAnimationFrame(animate)
  renderer.render(scene, camera)
}
animate()

/* ========= VIDEO ========= */
const video = document.getElementById("video")
video.muted = true
video.playsInline = true

navigator.mediaDevices.getUserMedia({
  video: {
    facingMode: "user",
    width: { ideal: 640 },
    height:{ ideal: 480 }
  }
})
.then(stream=>{
  video.srcObject = stream
  return video.play()
})
.catch(e=>alert("Camera error: " + e))

/* ========= HAND ========= */
const hands = new Hands({
  locateFile: f =>
    `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
})

hands.setOptions({
  maxNumHands:1,
  modelComplexity:0,
  minDetectionConfidence:0.6,
  minTrackingConfidence:0.6
})

let lastX=null, lastY=null

hands.onResults(res=>{
  if(!res.multiHandLandmarks?.length){
    lastX = lastY = null
    return
  }

  const p = res.multiHandLandmarks[0][9]

  if(lastX!==null){
    cube.rotation.y += (p.x-lastX)*6
    cube.rotation.x += (p.y-lastY)*6
  }

  lastX = p.x
  lastY = p.y
})

/* ========= LOOP (ลดเฟรมเพื่อมือถือ) ========= */
let lastTime = 0
async fu
